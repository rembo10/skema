{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE ScopedTypeVariables #-}

-- | Generate configuration artifacts from schema instances.
--
-- Usage:
--   generateFullYAML       -- Complete config.example.yaml
--   generateFullDocs       -- Complete configuration.md
--   printAPITypeInfo       -- Show what API types should look like
module Skema.Config.Generate
  ( generateFullYAML
  , generateFullDocs
  , printAPITypeInfo
  , writeConfigArtifacts
  ) where

import Skema.Config.Types
import Skema.Config.SchemaClass
import Skema.Config.SchemaInstances ()
import Data.Char (toUpper)
import qualified Data.Text as T
import qualified Data.Text.IO as TIO

-- | Generate complete YAML configuration example.
generateFullYAML :: Text
generateFullYAML =
  T.unlines $
    [ "# Skema Configuration File"
    , "#"
    , "# This file is automatically generated from ConfigSchema instances."
    , "# To modify structure, edit: server/src/Skema/Config/SchemaInstances.hs"
    , ""
    ]
    ++ [ deriveYAMLExample (Proxy @LibraryConfig)
       , ""
       , deriveYAMLExample (Proxy @SystemConfig)
       , ""
       , deriveYAMLExample (Proxy @ServerConfig)
       ]

-- | Generate complete markdown documentation.
generateFullDocs :: Text
generateFullDocs =
  T.unlines $
    [ "# Configuration Reference"
    , ""
    , "This documentation is automatically generated from the config schema."
    , ""
    ]
    ++ [ deriveMarkdownDocs (Proxy @LibraryConfig)
       , ""
       , deriveMarkdownDocs (Proxy @SystemConfig)
       , ""
       , deriveMarkdownDocs (Proxy @ServerConfig)
       ]

-- | Print information about API types (for manual implementation).
printAPITypeInfo :: IO ()
printAPITypeInfo = do
  putStrLn "=== API Response Type Fields ==="
  putStrLn ""

  let responseFields = concat
        [ deriveAPIResponse (Proxy @LibraryConfig)
        , deriveAPIResponse (Proxy @SystemConfig)
        , deriveAPIResponse (Proxy @ServerConfig)
        ]

  putStrLn "data ConfigResponse = ConfigResponse"
  forM_ (zip [1 :: Integer ..] responseFields) $ \(idx, (name, typ)) -> do
    let prefix = if idx == 1 then "  { " else "  , "
    putStrLn $ toString $ prefix <> camelCase name <> " :: " <> typ
  putStrLn "  }"
  putStrLn ""

  putStrLn "=== API Update Type Fields ==="
  putStrLn ""

  let updateFields = concat
        [ deriveAPIUpdate (Proxy @LibraryConfig)
        , deriveAPIUpdate (Proxy @SystemConfig)
        , deriveAPIUpdate (Proxy @ServerConfig)
        ]

  putStrLn "data ConfigUpdate = ConfigUpdate"
  forM_ (zip [1 :: Integer ..] updateFields) $ \(idx, (name, typ)) -> do
    let prefix = if idx == 1 then "  { " else "  , "
    putStrLn $ toString $ prefix <> camelCase name <> " :: " <> typ
  putStrLn "  }"
  putStrLn ""

  where
    -- Convert snake_case to camelCase for Haskell field names
    camelCase :: Text -> Text
    camelCase t =
      let parts = T.splitOn "_" t
          capitalized = case parts of
            [] -> ""
            (firstPart:rest) -> firstPart <> T.concat (map capitalizeFirst rest)
       in capitalized

    capitalizeFirst :: Text -> Text
    capitalizeFirst t = case T.uncons t of
      Nothing -> t
      Just (c, rest) -> T.cons (toUpper c) rest

-- | Write all generated artifacts to files.
writeConfigArtifacts :: IO ()
writeConfigArtifacts = do
  putStrLn "Generating configuration artifacts..."
  putStrLn ""

  -- Write YAML example
  let yaml = generateFullYAML
  TIO.writeFile "config.example.yaml" yaml
  putStrLn "âœ“ Generated: config.example.yaml"

  -- Print API type info for manual implementation
  putStrLn ""
  printAPITypeInfo
